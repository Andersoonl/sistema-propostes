generator client {
  provider = "prisma-client"
  output   = "../app/generated/prisma"
}

datasource db {
  provider = "sqlite"
}

// Máquinas fixas: VP1, VP2, HZEN
model Machine {
  id              String           @id @default(cuid())
  name            String           @unique
  productionDays  ProductionDay[]
  shiftOverrides  ShiftOverride[]
  downtimeReasons DowntimeReason[]
  shifts          MachineShift[]
  createdAt       DateTime         @default(now())
}

// Configuração de turno por máquina e dia da semana
model MachineShift {
  id           String   @id @default(cuid())
  machineId    String
  machine      Machine  @relation(fields: [machineId], references: [id], onDelete: Cascade)
  dayOfWeek    Int      // 0=Domingo, 1=Segunda, ..., 6=Sábado
  startTime    String   // HH:mm
  endTime      String   // HH:mm
  breakMinutes Int      // Pausas em minutos
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([machineId, dayOfWeek])
}

// Produtos que podem ser produzidos
model Product {
  id                 String              @id @default(cuid())
  name               String              @unique
  category           String?             // PISO INTERTRAVADO, BLOCO DE CONCRETO
  subcategory        String?             // PAVER, UNISTEIN, FAMILIA 09, etc.
  productionItems    ProductionItem[]
  costRecipe         CostRecipe?
  inventoryMovements InventoryMovement[]
  createdAt          DateTime            @default(now())
}

// Ingredientes/Materiais (dados mestre)
model Ingredient {
  id              String          @id @default(cuid())
  name            String          @unique
  unit            String          // kg, ml, un
  unitPrice       Float           // R$/unidade
  recipeItems     RecipeItem[]
  materialEntries MaterialEntry[]
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
}

// Receita de custo do produto
model CostRecipe {
  id               String       @id @default(cuid())
  productId        String       @unique
  product          Product      @relation(fields: [productId], references: [id], onDelete: Cascade)

  // Parâmetros de produção
  density          Float?       // Densidade média
  piecesPerCycle   Int          // Peças por ciclo
  cyclesPerBatch   Float        // Ciclos por traço
  piecesPerM2      Float        // Peças por m²
  avgPieceWeightKg Float        // Peso médio da peça (kg)
  piecesPerPallet  Int?         // Peças por pallet (blocos)
  m2PerPallet      Float?       // m² por pallet (pisos)

  // Custos extras (R$)
  palletCost       Float        @default(0)
  strappingCost    Float        @default(0)
  plasticCost      Float        @default(0)

  items            RecipeItem[]
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
}

// Itens da receita (ingrediente + quantidade)
model RecipeItem {
  id           String     @id @default(cuid())
  recipeId     String
  recipe       CostRecipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  ingredientId String
  ingredient   Ingredient @relation(fields: [ingredientId], references: [id], onDelete: Cascade)
  quantity     Float      // Quantidade por traço
  createdAt    DateTime   @default(now())

  @@unique([recipeId, ingredientId])
}

// Override de turno por dia e máquina (casos raros)
model ShiftOverride {
  id              String   @id @default(cuid())
  machineId       String
  machine         Machine  @relation(fields: [machineId], references: [id], onDelete: Cascade)
  date            DateTime
  startTime       String   // HH:mm
  endTime         String   // HH:mm
  breakMinutes    Int      // Pausas em minutos
  createdAt       DateTime @default(now())

  @@unique([machineId, date])
}

// Dia de produção (um registro por máquina por dia)
model ProductionDay {
  id              String           @id @default(cuid())
  machineId       String
  machine         Machine          @relation(fields: [machineId], references: [id], onDelete: Cascade)
  date            DateTime
  hasProductSwap  Boolean          @default(false) // Troca de produto?
  notes           String?
  productionItems ProductionItem[]
  downtimeEvents  DowntimeEvent[]
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  @@unique([machineId, date])
}

// Item de produção (produto + ciclos)
// Máximo 2 por dia por máquina
model ProductionItem {
  id              String        @id @default(cuid())
  productionDayId String
  productionDay   ProductionDay @relation(fields: [productionDayId], references: [id], onDelete: Cascade)
  productId       String
  product         Product       @relation(fields: [productId], references: [id], onDelete: Cascade)
  cycles          Int           // Quantidade de ciclos
  pieces          Int?          // Peças produzidas (calculado: ciclos * piecesPerCycle da receita)
  pallets         Float?        // Pallets (calculado: peças / piecesPerPallet)
  areaM2          Float?        // m² (calculado: peças / piecesPerM2)
  startTime       String?       // HH:mm (opcional)
  endTime         String?       // HH:mm (opcional)
  createdAt       DateTime      @default(now())

  @@unique([productionDayId, productId])
}

// Motivos de parada (hierarquia NV1 -> NV2 -> NV3)
model DowntimeReason {
  id             String           @id @default(cuid())
  name           String
  level          Int              // 1, 2, or 3
  parentId       String?
  parent         DowntimeReason?  @relation("ReasonHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children       DowntimeReason[] @relation("ReasonHierarchy")
  machineId      String?
  machine        Machine?         @relation(fields: [machineId], references: [id], onDelete: Cascade)
  downtimeEvents DowntimeEvent[]
  createdAt      DateTime         @default(now())

  @@unique([name, level, parentId, machineId])
}

// Evento de parada
model DowntimeEvent {
  id              String         @id @default(cuid())
  productionDayId String
  productionDay   ProductionDay  @relation(fields: [productionDayId], references: [id], onDelete: Cascade)
  reasonId        String         // Motivo (NV1, NV2 ou NV3)
  reason          DowntimeReason @relation(fields: [reasonId], references: [id], onDelete: Cascade)
  durationMinutes Int            // Duração em minutos
  notes           String?        // Observação opcional
  createdAt       DateTime       @default(now())
}

// Entrada de matéria prima (compras)
model MaterialEntry {
  id            String     @id @default(cuid())
  ingredientId  String
  ingredient    Ingredient @relation(fields: [ingredientId], references: [id], onDelete: Cascade)
  date          DateTime
  quantity      Float      // quantidade comprada
  unitPrice     Float      // preço unitário na compra
  supplier      String?    // fornecedor
  invoiceNumber String?    // número NF
  notes         String?
  createdAt     DateTime   @default(now())
}

// Movimentação de estoque de produto acabado
model InventoryMovement {
  id              String   @id @default(cuid())
  productId       String
  product         Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  date            DateTime
  type            String   // 'IN' (produção) ou 'OUT' (saída/venda)
  quantityPieces  Int
  quantityPallets Float?
  areaM2          Float?
  notes           String?
  productionDayId String?  // referência ao dia de produção (quando tipo IN automático)
  createdAt       DateTime @default(now())
}
